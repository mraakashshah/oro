package codesearch_test

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"oro/pkg/codesearch"
)

// testFixtureGo is a realistic 500+ line Go file used to test summarization.
// It simulates a real-world HTTP server with substantial function bodies,
// which is the typical case where summarization provides 90%+ token savings.
// The key property: function bodies contain lots of implementation detail
// (logging, error handling, HTTP plumbing) that the summary compresses away.
var testFixtureGo = strings.Join([]string{
	"package server",
	"",
	"import (",
	`	"context"`,
	`	"encoding/json"`,
	`	"fmt"`,
	`	"io"`,
	`	"log"`,
	`	"net/http"`,
	`	"sort"`,
	`	"strings"`,
	`	"sync"`,
	`	"time"`,
	")",
	"",
	"// DefaultPort is the default HTTP server port.",
	"const DefaultPort = 8080",
	"",
	"// MaxConnections limits concurrent connections.",
	"const MaxConnections = 1000",
	"",
	"// Version is the server version string.",
	`var Version = "1.0.0"`,
	"",
	"// ErrNotFound is returned when a resource is not found.",
	`var ErrNotFound = fmt.Errorf("resource not found")`,
	"",
	"// Handler defines the interface for HTTP request handlers.",
	"type Handler interface {",
	"	// ServeHTTP handles an HTTP request.",
	"	ServeHTTP(w http.ResponseWriter, r *http.Request)",
	"	// Name returns the handler name for logging.",
	"	Name() string",
	"}",
	"",
	"// Middleware is a function that wraps a Handler.",
	"type Middleware func(Handler) Handler",
	"",
	"// Config holds server configuration.",
	"type Config struct {",
	"	Port            int",
	"	Host            string",
	"	ReadTimeout     time.Duration",
	"	WriteTimeout    time.Duration",
	"	MaxHeaderBytes  int",
	"}",
	"",
	"// Route represents a registered HTTP route.",
	"type Route struct {",
	"	Method  string",
	"	Path    string",
	"	Handler Handler",
	"}",
	"",
	"// Server is the main HTTP server.",
	"type Server struct {",
	"	config     Config",
	"	router     *Router",
	"	middleware []Middleware",
	"	mu         sync.RWMutex",
	"	started    bool",
	"	logger     *log.Logger",
	"}",
	"",
	"// Router handles URL routing and dispatching.",
	"type Router struct {",
	"	routes   map[string][]Route",
	"	notFound Handler",
	"}",
	"",
	"// Response is a generic JSON response envelope.",
	"type Response struct {",
	"	Status  int",
	"	Message string",
	"	Data    interface{}",
	"	Error   string",
	"}",
	"",
	"// NewServer creates a new Server with the given configuration.",
	"func NewServer(cfg Config) *Server {",
	"	if cfg.Port == 0 {",
	"		cfg.Port = DefaultPort",
	"	}",
	"	if cfg.ReadTimeout == 0 {",
	"		cfg.ReadTimeout = 30 * time.Second",
	"	}",
	"	if cfg.WriteTimeout == 0 {",
	"		cfg.WriteTimeout = 30 * time.Second",
	"	}",
	"	if cfg.MaxHeaderBytes == 0 {",
	"		cfg.MaxHeaderBytes = 1 << 20",
	"	}",
	"	return &Server{",
	"		config: cfg,",
	"		router: NewRouter(),",
	"		logger: log.Default(),",
	"	}",
	"}",
	"",
	"// NewRouter creates an empty Router.",
	"func NewRouter() *Router {",
	"	return &Router{",
	"		routes: make(map[string][]Route),",
	"	}",
	"}",
	"",
	"// Start begins listening for HTTP requests.",
	"func (s *Server) Start(ctx context.Context) error {",
	"	s.mu.Lock()",
	"	if s.started {",
	"		s.mu.Unlock()",
	`		return fmt.Errorf("server already started")`,
	"	}",
	"	s.started = true",
	"	s.mu.Unlock()",
	"",
	`	addr := fmt.Sprintf("%s:%d", s.config.Host, s.config.Port)`,
	"	srv := &http.Server{",
	"		Addr:           addr,",
	"		Handler:        s,",
	"		ReadTimeout:    s.config.ReadTimeout,",
	"		WriteTimeout:   s.config.WriteTimeout,",
	"		MaxHeaderBytes: s.config.MaxHeaderBytes,",
	"	}",
	"",
	"	errCh := make(chan error, 1)",
	"	go func() {",
	"		errCh <- srv.ListenAndServe()",
	"	}()",
	"",
	`	s.logger.Printf("server listening on %s", addr)`,
	"",
	"	select {",
	"	case err := <-errCh:",
	"		return err",
	"	case <-ctx.Done():",
	"		shutdownCtx, cancel := context.WithTimeout(",
	"			context.Background(), 10*time.Second,",
	"		)",
	"		defer cancel()",
	"		return srv.Shutdown(shutdownCtx)",
	"	}",
	"}",
	"",
	"// ServeHTTP implements the http.Handler interface.",
	"func (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {",
	"	start := time.Now()",
	"	handler := s.router.Match(r.Method, r.URL.Path)",
	"	if handler == nil {",
	"		writeJSON(w, http.StatusNotFound, Response{",
	"			Status:  http.StatusNotFound,",
	`			Message: "not found",`,
	"		})",
	"		return",
	"	}",
	"",
	"	// Apply middleware chain in reverse order.",
	"	var h Handler = handler",
	"	for i := len(s.middleware) - 1; i >= 0; i-- {",
	"		h = s.middleware[i](h)",
	"	}",
	"	h.ServeHTTP(w, r)",
	"",
	"	duration := time.Since(start)",
	"	if duration > 500*time.Millisecond {",
	`		s.logger.Printf("slow request: %s %s took %v", r.Method, r.URL.Path, duration)`,
	"	}",
	"}",
	"",
	"// Use adds middleware to the server's middleware chain.",
	"func (s *Server) Use(mw ...Middleware) {",
	"	s.middleware = append(s.middleware, mw...)",
	"}",
	"",
	"// Handle registers a route with the given method and path.",
	"func (s *Server) Handle(method, path string, h Handler) {",
	"	s.router.Add(method, path, h)",
	"}",
	"",
	"// Match finds the handler for a given method and path.",
	"func (r *Router) Match(method, path string) Handler {",
	"	routes, ok := r.routes[method]",
	"	if !ok {",
	"		return nil",
	"	}",
	"	for _, route := range routes {",
	"		if route.Path == path {",
	"			return route.Handler",
	"		}",
	"	}",
	"	return r.notFound",
	"}",
	"",
	"// Add registers a new route in the router.",
	"func (r *Router) Add(method, path string, h Handler) {",
	"	r.routes[method] = append(r.routes[method], Route{",
	"		Method:  method,",
	"		Path:    path,",
	"		Handler: h,",
	"	})",
	"}",
	"",
	"// Routes returns all registered routes sorted by method and path.",
	"func (r *Router) Routes() []Route {",
	"	var all []Route",
	"	for _, routes := range r.routes {",
	"		all = append(all, routes...)",
	"	}",
	"	sort.Slice(all, func(i, j int) bool {",
	"		if all[i].Method != all[j].Method {",
	"			return all[i].Method < all[j].Method",
	"		}",
	"		return all[i].Path < all[j].Path",
	"	})",
	"	return all",
	"}",
	"",
	"// writeJSON writes a JSON response with the given status code.",
	"func writeJSON(w http.ResponseWriter, status int, v interface{}) {",
	`	w.Header().Set("Content-Type", "application/json; charset=utf-8")`,
	`	w.Header().Set("X-Content-Type-Options", "nosniff")`,
	"	w.WriteHeader(status)",
	"	enc := json.NewEncoder(w)",
	"	enc.SetIndent(\"\", \"  \")",
	"	if err := enc.Encode(v); err != nil {",
	`		log.Printf("failed to write JSON response: %v", err)`,
	"	}",
	"}",
	"",
	"// readJSON reads and validates a JSON request body.",
	"func readJSON(r io.Reader, v interface{}) error {",
	"	dec := json.NewDecoder(r)",
	"	dec.DisallowUnknownFields()",
	"	if err := dec.Decode(v); err != nil {",
	`		return fmt.Errorf("invalid JSON: %w", err)`,
	"	}",
	"	if dec.More() {",
	`		return fmt.Errorf("unexpected trailing data after JSON body")`,
	"	}",
	"	return nil",
	"}",
	"",
	"// LoggingMiddleware logs each request with method, path, and duration.",
	"func LoggingMiddleware(logger *log.Logger) Middleware {",
	"	return func(next Handler) Handler {",
	"		return &loggingHandler{next: next, logger: logger}",
	"	}",
	"}",
	"",
	"type loggingHandler struct {",
	"	next   Handler",
	"	logger *log.Logger",
	"}",
	"",
	"func (h *loggingHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {",
	"	start := time.Now()",
	`	h.logger.Printf("-> %s %s from %s", r.Method, r.URL.Path, r.RemoteAddr)`,
	"	h.next.ServeHTTP(w, r)",
	"	elapsed := time.Since(start)",
	`	h.logger.Printf("<- %s %s completed in %v", r.Method, r.URL.Path, elapsed)`,
	"	if elapsed > time.Second {",
	`		h.logger.Printf("WARNING: slow request %s %s: %v", r.Method, r.URL.Path, elapsed)`,
	"	}",
	"}",
	"",
	"func (h *loggingHandler) Name() string {",
	`	return "logging(" + h.next.Name() + ")"`,
	"}",
	"",
	"// RecoveryMiddleware recovers from panics and returns a 500 response.",
	"func RecoveryMiddleware() Middleware {",
	"	return func(next Handler) Handler {",
	"		return &recoveryHandler{next: next}",
	"	}",
	"}",
	"",
	"type recoveryHandler struct {",
	"	next Handler",
	"}",
	"",
	"func (h *recoveryHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {",
	"	defer func() {",
	"		if err := recover(); err != nil {",
	`			log.Printf("panic recovered in %s %s: %v", r.Method, r.URL.Path, err)`,
	"			writeJSON(w, http.StatusInternalServerError, Response{",
	"				Status:  http.StatusInternalServerError,",
	`				Message: "internal server error",`,
	`				Error:   fmt.Sprintf("%v", err),`,
	"			})",
	"		}",
	"	}()",
	"	h.next.ServeHTTP(w, r)",
	"}",
	"",
	"func (h *recoveryHandler) Name() string {",
	`	return "recovery(" + h.next.Name() + ")"`,
	"}",
	"",
	"// HealthCheck returns a simple health check handler function.",
	"func HealthCheck() http.HandlerFunc {",
	"	return func(w http.ResponseWriter, r *http.Request) {",
	"		writeJSON(w, http.StatusOK, Response{",
	"			Status:  http.StatusOK,",
	`			Message: "healthy",`,
	`			Data:    map[string]string{"version": Version},`,
	"		})",
	"	}",
	"}",
	"",
	"// CORSMiddleware adds CORS headers to responses.",
	"func CORSMiddleware(allowedOrigins []string) Middleware {",
	"	allowed := make(map[string]bool, len(allowedOrigins))",
	"	for _, origin := range allowedOrigins {",
	"		allowed[strings.ToLower(origin)] = true",
	"	}",
	"	return func(next Handler) Handler {",
	"		return &corsHandler{next: next, allowed: allowed}",
	"	}",
	"}",
	"",
	"type corsHandler struct {",
	"	next    Handler",
	"	allowed map[string]bool",
	"}",
	"",
	"func (h *corsHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {",
	`	origin := r.Header.Get("Origin")`,
	"	if origin != \"\" && h.allowed[strings.ToLower(origin)] {",
	`		w.Header().Set("Access-Control-Allow-Origin", origin)`,
	`		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")`,
	`		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")`,
	`		w.Header().Set("Access-Control-Max-Age", "86400")`,
	"	}",
	`	if r.Method == "OPTIONS" {`,
	"		w.WriteHeader(http.StatusNoContent)",
	"		return",
	"	}",
	"	h.next.ServeHTTP(w, r)",
	"}",
	"",
	"func (h *corsHandler) Name() string {",
	`	return "cors(" + h.next.Name() + ")"`,
	"}",
	"",
	"// RateLimiter provides basic per-IP rate limiting.",
	"type RateLimiter struct {",
	"	mu       sync.Mutex",
	"	requests map[string][]time.Time",
	"	limit    int",
	"	window   time.Duration",
	"}",
	"",
	"// NewRateLimiter creates a rate limiter.",
	"func NewRateLimiter(limit int, window time.Duration) *RateLimiter {",
	"	return &RateLimiter{",
	"		requests: make(map[string][]time.Time),",
	"		limit:    limit,",
	"		window:   window,",
	"	}",
	"}",
	"",
	"// Allow checks if a request from the given IP should be allowed.",
	"func (rl *RateLimiter) Allow(ip string) bool {",
	"	rl.mu.Lock()",
	"	defer rl.mu.Unlock()",
	"",
	"	now := time.Now()",
	"	cutoff := now.Add(-rl.window)",
	"",
	"	// Remove expired entries.",
	"	times := rl.requests[ip]",
	"	valid := times[:0]",
	"	for _, t := range times {",
	"		if t.After(cutoff) {",
	"			valid = append(valid, t)",
	"		}",
	"	}",
	"	rl.requests[ip] = valid",
	"",
	"	if len(valid) >= rl.limit {",
	"		return false",
	"	}",
	"",
	"	rl.requests[ip] = append(rl.requests[ip], now)",
	"	return true",
	"}",
	"",
	"// Cleanup removes expired entries from all IPs.",
	"func (rl *RateLimiter) Cleanup() {",
	"	rl.mu.Lock()",
	"	defer rl.mu.Unlock()",
	"",
	"	now := time.Now()",
	"	cutoff := now.Add(-rl.window)",
	"",
	"	for ip, times := range rl.requests {",
	"		valid := times[:0]",
	"		for _, t := range times {",
	"			if t.After(cutoff) {",
	"				valid = append(valid, t)",
	"			}",
	"		}",
	"		if len(valid) == 0 {",
	"			delete(rl.requests, ip)",
	"		} else {",
	"			rl.requests[ip] = valid",
	"		}",
	"	}",
	"}",
	"",
	"// parseIP extracts the IP from a request's RemoteAddr.",
	"func parseIP(remoteAddr string) string {",
	"	if idx := strings.LastIndex(remoteAddr, \":\"); idx != -1 {",
	"		return remoteAddr[:idx]",
	"	}",
	"	return remoteAddr",
	"}",
	"",
	"// formatDuration formats a duration for human-readable logging.",
	"func formatDuration(d time.Duration) string {",
	"	switch {",
	"	case d < time.Microsecond:",
	`		return fmt.Sprintf("%dns", d.Nanoseconds())`,
	"	case d < time.Millisecond:",
	`		return fmt.Sprintf("%.1fus", float64(d.Nanoseconds())/1000)`,
	"	case d < time.Second:",
	`		return fmt.Sprintf("%.1fms", float64(d.Nanoseconds())/1e6)`,
	"	default:",
	`		return fmt.Sprintf("%.2fs", d.Seconds())`,
	"	}",
	"}",
	"",
	"// validateConfig checks that a Config has all required fields.",
	"func validateConfig(cfg Config) error {",
	"	if cfg.Port < 0 || cfg.Port > 65535 {",
	`		return fmt.Errorf("invalid port: %d", cfg.Port)`,
	"	}",
	"	if cfg.ReadTimeout < 0 {",
	`		return fmt.Errorf("read timeout must be non-negative")`,
	"	}",
	"	if cfg.WriteTimeout < 0 {",
	`		return fmt.Errorf("write timeout must be non-negative")`,
	"	}",
	"	if cfg.MaxHeaderBytes < 0 {",
	`		return fmt.Errorf("max header bytes must be non-negative")`,
	"	}",
	"	return nil",
	"}",
	"",
	"// mergeConfig fills zero-valued fields in dst from src.",
	"func mergeConfig(dst, src Config) Config {",
	"	if dst.Port == 0 {",
	"		dst.Port = src.Port",
	"	}",
	"	if dst.Host == \"\" {",
	"		dst.Host = src.Host",
	"	}",
	"	if dst.ReadTimeout == 0 {",
	"		dst.ReadTimeout = src.ReadTimeout",
	"	}",
	"	if dst.WriteTimeout == 0 {",
	"		dst.WriteTimeout = src.WriteTimeout",
	"	}",
	"	if dst.MaxHeaderBytes == 0 {",
	"		dst.MaxHeaderBytes = src.MaxHeaderBytes",
	"	}",
	"	return dst",
	"}",
	"",
	"// splitPath splits a URL path into segments, ignoring empty segments.",
	"func splitPath(path string) []string {",
	"	parts := strings.Split(path, \"/\")",
	"	result := make([]string, 0, len(parts))",
	"	for _, p := range parts {",
	"		if p != \"\" {",
	"			result = append(result, p)",
	"		}",
	"	}",
	"	return result",
	"}",
	"",
	"// buildRouteTable constructs a debug string showing all registered routes",
	"// grouped by HTTP method, including middleware count and handler names.",
	"func buildRouteTable(r *Router, middleware []Middleware) string {",
	"	var sb strings.Builder",
	`	sb.WriteString("=== Route Table ===\n")`,
	`	sb.WriteString(fmt.Sprintf("Middleware stack: %d layers\n\n", len(middleware)))`,
	"",
	"	methods := make([]string, 0, len(r.routes))",
	"	for m := range r.routes {",
	"		methods = append(methods, m)",
	"	}",
	"	sort.Strings(methods)",
	"",
	"	totalRoutes := 0",
	"	for _, method := range methods {",
	"		routes := r.routes[method]",
	`		sb.WriteString(fmt.Sprintf("[%s] %d routes:\n", method, len(routes)))`,
	"		for i, route := range routes {",
	"			name := \"<anonymous>\"",
	"			if route.Handler != nil {",
	"				name = route.Handler.Name()",
	"			}",
	`			sb.WriteString(fmt.Sprintf("  %d. %s -> %s\n", i+1, route.Path, name))`,
	"			totalRoutes++",
	"		}",
	"		sb.WriteByte('\\n')",
	"	}",
	"",
	`	sb.WriteString(fmt.Sprintf("Total: %d routes across %d methods\n", totalRoutes, len(methods)))`,
	"	return sb.String()",
	"}",
	"",
	"// gracefulShutdown performs a graceful shutdown sequence for the server,",
	"// draining active connections and closing resources in order.",
	"func (s *Server) gracefulShutdown(ctx context.Context) error {",
	"	s.mu.Lock()",
	"	if !s.started {",
	"		s.mu.Unlock()",
	`		return fmt.Errorf("server not started")`,
	"	}",
	"	s.mu.Unlock()",
	"",
	`	s.logger.Printf("initiating graceful shutdown...")`,
	"",
	"	// Phase 1: Stop accepting new connections.",
	`	s.logger.Printf("phase 1: stopping new connections")`,
	"	s.mu.Lock()",
	"	s.started = false",
	"	s.mu.Unlock()",
	"",
	"	// Phase 2: Wait for active requests to complete.",
	`	s.logger.Printf("phase 2: draining active requests")`,
	"	deadline, hasDeadline := ctx.Deadline()",
	"	if hasDeadline {",
	"		remaining := time.Until(deadline)",
	`		s.logger.Printf("shutdown deadline in %v", remaining)`,
	"		if remaining < time.Second {",
	`			s.logger.Printf("WARNING: less than 1 second remaining for shutdown")`,
	"		}",
	"	}",
	"",
	"	// Phase 3: Close idle connections.",
	`	s.logger.Printf("phase 3: closing idle connections")`,
	"	select {",
	"	case <-ctx.Done():",
	`		s.logger.Printf("shutdown deadline exceeded, forcing close")`,
	"		return ctx.Err()",
	"	case <-time.After(100 * time.Millisecond):",
	"		// Brief pause to let connections drain.",
	"	}",
	"",
	"	// Phase 4: Final cleanup.",
	`	s.logger.Printf("phase 4: final cleanup complete")`,
	"	return nil",
	"}",
	"",
	"// handleAPIRequest processes an API request with full validation,",
	"// authentication checking, rate limiting, and response formatting.",
	"func handleAPIRequest(w http.ResponseWriter, r *http.Request, rl *RateLimiter) {",
	"	// Extract client IP for rate limiting.",
	"	ip := parseIP(r.RemoteAddr)",
	`	forwarded := r.Header.Get("X-Forwarded-For")`,
	"	if forwarded != \"\" {",
	"		parts := strings.Split(forwarded, \",\")",
	"		if len(parts) > 0 {",
	"			ip = strings.TrimSpace(parts[0])",
	"		}",
	"	}",
	"",
	"	// Check rate limit.",
	"	if !rl.Allow(ip) {",
	`		w.Header().Set("Retry-After", "60")`,
	"		writeJSON(w, http.StatusTooManyRequests, Response{",
	"			Status:  http.StatusTooManyRequests,",
	`			Message: "rate limit exceeded",`,
	`			Error:   fmt.Sprintf("too many requests from %s", ip),`,
	"		})",
	"		return",
	"	}",
	"",
	"	// Validate content type for POST/PUT/PATCH.",
	"	if r.Method == \"POST\" || r.Method == \"PUT\" || r.Method == \"PATCH\" {",
	`		ct := r.Header.Get("Content-Type")`,
	`		if !strings.HasPrefix(ct, "application/json") {`,
	"			writeJSON(w, http.StatusUnsupportedMediaType, Response{",
	"				Status:  http.StatusUnsupportedMediaType,",
	`				Message: "content type must be application/json",`,
	"			})",
	"			return",
	"		}",
	"	}",
	"",
	"	// Validate authorization header.",
	`	auth := r.Header.Get("Authorization")`,
	"	if auth == \"\" {",
	"		writeJSON(w, http.StatusUnauthorized, Response{",
	"			Status:  http.StatusUnauthorized,",
	`			Message: "missing authorization header",`,
	"		})",
	"		return",
	"	}",
	`	if !strings.HasPrefix(auth, "Bearer ") {`,
	"		writeJSON(w, http.StatusUnauthorized, Response{",
	"			Status:  http.StatusUnauthorized,",
	`			Message: "invalid authorization scheme, expected Bearer",`,
	"		})",
	"		return",
	"	}",
	"",
	"	// Parse request path for API version.",
	"	segments := splitPath(r.URL.Path)",
	"	if len(segments) < 2 {",
	"		writeJSON(w, http.StatusBadRequest, Response{",
	"			Status:  http.StatusBadRequest,",
	`			Message: "invalid API path, expected /api/v{N}/...",`,
	"		})",
	"		return",
	"	}",
	`	if segments[0] != "api" {`,
	"		writeJSON(w, http.StatusNotFound, Response{",
	"			Status:  http.StatusNotFound,",
	`			Message: "not found",`,
	"		})",
	"		return",
	"	}",
	"",
	"	// Success response.",
	"	writeJSON(w, http.StatusOK, Response{",
	"		Status:  http.StatusOK,",
	`		Message: "ok",`,
	`		Data:    map[string]string{"ip": ip, "version": segments[1]},`,
	"	})",
	"}",
	"",
	"// collectMetrics gathers runtime metrics and formats them for the",
	"// health endpoint, including request counts, error rates, and latencies.",
	"func collectMetrics(routes []Route, uptime time.Duration) map[string]interface{} {",
	"	metrics := make(map[string]interface{})",
	"",
	`	metrics["uptime_seconds"] = uptime.Seconds()`,
	`	metrics["uptime_human"] = formatDuration(uptime)`,
	`	metrics["version"] = Version`,
	`	metrics["route_count"] = len(routes)`,
	"",
	"	// Group routes by method.",
	"	methodCounts := make(map[string]int)",
	"	for _, r := range routes {",
	"		methodCounts[r.Method]++",
	"	}",
	`	metrics["routes_by_method"] = methodCounts`,
	"",
	"	// Calculate route path depths.",
	"	maxDepth := 0",
	"	totalDepth := 0",
	"	for _, r := range routes {",
	"		depth := len(splitPath(r.Path))",
	"		if depth > maxDepth {",
	"			maxDepth = depth",
	"		}",
	"		totalDepth += depth",
	"	}",
	`	metrics["max_path_depth"] = maxDepth`,
	"	if len(routes) > 0 {",
	`		metrics["avg_path_depth"] = float64(totalDepth) / float64(len(routes))`,
	"	}",
	"",
	"	// Build handler names list.",
	"	names := make([]string, 0, len(routes))",
	"	seen := make(map[string]bool)",
	"	for _, r := range routes {",
	"		if r.Handler != nil {",
	"			n := r.Handler.Name()",
	"			if !seen[n] {",
	"				names = append(names, n)",
	"				seen[n] = true",
	"			}",
	"		}",
	"	}",
	"	sort.Strings(names)",
	`	metrics["handler_names"] = names`,
	"",
	"	return metrics",
	"}",
	"",
	"// normalizeHeaders lowercases all header keys and trims whitespace",
	"// from values, returning a cleaned copy of the header map.",
	"func normalizeHeaders(headers http.Header) http.Header {",
	"	normalized := make(http.Header, len(headers))",
	"	for key, values := range headers {",
	"		lowerKey := strings.ToLower(key)",
	"		cleaned := make([]string, 0, len(values))",
	"		for _, v := range values {",
	"			trimmed := strings.TrimSpace(v)",
	"			if trimmed != \"\" {",
	"				cleaned = append(cleaned, trimmed)",
	"			}",
	"		}",
	"		if len(cleaned) > 0 {",
	"			normalized[lowerKey] = cleaned",
	"		}",
	"	}",
	"	return normalized",
	"}",
	"",
	"// buildErrorChain walks an error chain and returns a slice of messages.",
	"func buildErrorChain(err error) []string {",
	"	if err == nil {",
	"		return nil",
	"	}",
	"	var chain []string",
	"	for err != nil {",
	"		chain = append(chain, err.Error())",
	`		unwrapper, ok := err.(interface{ Unwrap() error })`,
	"		if !ok {",
	"			break",
	"		}",
	"		err = unwrapper.Unwrap()",
	"	}",
	"	return chain",
	"}",
	"",
}, "\n")

func writeTempGoFile(t *testing.T, content string) string {
	t.Helper()
	dir := t.TempDir()
	path := filepath.Join(dir, "fixture.go")
	if err := os.WriteFile(path, []byte(content), 0o600); err != nil {
		t.Fatalf("failed to write fixture: %v", err)
	}
	return path
}

func TestSummarize(t *testing.T) {
	path := writeTempGoFile(t, testFixtureGo)

	summary, err := codesearch.Summarize(path)
	if err != nil {
		t.Fatalf("codesearch.Summarize() error: %v", err)
	}

	// --- Token reduction: summary should be <10% of original ---
	// Rough token estimate: 1 token ~ 4 chars.
	originalTokens := len(testFixtureGo) / 4
	summaryTokens := len(summary) / 4
	ratio := float64(summaryTokens) / float64(originalTokens)
	t.Logf("original ~%d tokens, summary ~%d tokens, ratio %.1f%%", originalTokens, summaryTokens, ratio*100)
	if ratio > 0.10 {
		t.Errorf("summary is %.1f%% of original, want <10%%\nsummary:\n%s", ratio*100, summary)
	}

	// --- Must include package name ---
	if !strings.Contains(summary, "package server") {
		t.Error("summary missing package declaration")
	}

	// --- Must include imports ---
	if !strings.Contains(summary, "context") {
		t.Error("summary missing import 'context'")
	}
	if !strings.Contains(summary, "net/http") {
		t.Error("summary missing import 'net/http'")
	}

	// --- Must include exported function signatures ---
	exportedFuncs := []string{
		"NewServer",
		"NewRouter",
		"Start",
		"ServeHTTP",
		"Use",
		"Handle",
		"Match",
		"Add",
		"LoggingMiddleware",
		"RecoveryMiddleware",
		"HealthCheck",
	}
	for _, fn := range exportedFuncs {
		if !strings.Contains(summary, fn) {
			t.Errorf("summary missing exported function %q", fn)
		}
	}

	// --- Must include type declarations ---
	types := []string{
		"Handler",
		"Middleware",
		"Config",
		"Route",
		"Server",
		"Router",
		"Response",
	}
	for _, typ := range types {
		if !strings.Contains(summary, typ) {
			t.Errorf("summary missing type %q", typ)
		}
	}

	// --- Must include line numbers ---
	// Line numbers appear as "L<number>" or ":<number>" in the output.
	if !strings.Contains(summary, ":") && !strings.Contains(summary, "L") {
		t.Error("summary missing line number references")
	}

	// --- Must include const/var declarations ---
	if !strings.Contains(summary, "DefaultPort") {
		t.Error("summary missing const DefaultPort")
	}
	if !strings.Contains(summary, "MaxConnections") {
		t.Error("summary missing const MaxConnections")
	}
	if !strings.Contains(summary, "Version") {
		t.Error("summary missing var Version")
	}
	if !strings.Contains(summary, "ErrNotFound") {
		t.Error("summary missing var ErrNotFound")
	}

	// --- Must include struct fields ---
	if !strings.Contains(summary, "Port") {
		t.Error("summary missing Config.Port field")
	}
	if !strings.Contains(summary, "Host") {
		t.Error("summary missing Config.Host field")
	}

	// --- Must include interface methods ---
	if !strings.Contains(summary, "Name") {
		t.Error("summary missing Handler.Name method")
	}

	t.Logf("summary:\n%s", summary)
}

func TestSummarizeNonGoFile(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "readme.md")
	if err := os.WriteFile(path, []byte("# Hello World\n"), 0o600); err != nil {
		t.Fatalf("failed to write fixture: %v", err)
	}

	_, err := codesearch.Summarize(path)
	if err == nil {
		t.Fatal("codesearch.Summarize() expected error for non-Go file, got nil")
	}
}

func TestSummarizeNonExistentFile(t *testing.T) {
	_, err := codesearch.Summarize("/nonexistent/path/to/file.go")
	if err == nil {
		t.Fatal("codesearch.Summarize() expected error for nonexistent file, got nil")
	}
}

func TestSummarizeSyntaxError(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "bad.go")
	content := "package main\n\nfunc broken( {\n}\n"
	if err := os.WriteFile(path, []byte(content), 0o600); err != nil {
		t.Fatalf("failed to write fixture: %v", err)
	}

	_, err := codesearch.Summarize(path)
	if err == nil {
		t.Fatal("codesearch.Summarize() expected error for syntax error, got nil")
	}
}

func TestSummarizeCountsUnexportedSymbols(t *testing.T) {
	path := writeTempGoFile(t, testFixtureGo)

	summary, err := codesearch.Summarize(path)
	if err != nil {
		t.Fatalf("codesearch.Summarize() error: %v", err)
	}

	// Unexported functions and types are counted (not listed individually)
	// to maximize token savings.
	if !strings.Contains(summary, "unexported funcs") {
		t.Error("summary missing unexported function count")
	}
	if !strings.Contains(summary, "unexported types") {
		t.Error("summary missing unexported type count")
	}
}

func TestSummarizeIncludesMethodReceivers(t *testing.T) {
	path := writeTempGoFile(t, testFixtureGo)

	summary, err := codesearch.Summarize(path)
	if err != nil {
		t.Fatalf("codesearch.Summarize() error: %v", err)
	}

	// Methods should show their receiver type.
	if !strings.Contains(summary, "Server") || !strings.Contains(summary, "Start") {
		t.Error("summary missing method with receiver (Server.Start)")
	}
	if !strings.Contains(summary, "Router") || !strings.Contains(summary, "Match") {
		t.Error("summary missing method with receiver (Router.Match)")
	}
}
