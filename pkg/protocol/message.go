// Package protocol defines UDS message types for the Oro dispatcher-worker protocol.
// Messages are line-delimited JSON over Unix domain sockets.
package protocol

import (
	"fmt"
	"regexp"
	"time"
)

// MaxMessageSize is the maximum size in bytes for a single UDS message.
// Scanner buffers are configured to accept up to this size.
const MaxMessageSize = 1 * 1024 * 1024 // 1 MB

// MessageType identifies the kind of UDS message.
type MessageType string

// Dispatcher -> Worker message types.
const (
	MsgAssign          MessageType = "ASSIGN"
	MsgShutdown        MessageType = "SHUTDOWN"
	MsgPrepareShutdown MessageType = "PREPARE_SHUTDOWN"
	MsgPreempt         MessageType = "PREEMPT"
	MsgACK             MessageType = "ACK"
	MsgReviewResult    MessageType = "REVIEW_RESULT"
)

// Worker -> Dispatcher message types.
const (
	MsgHeartbeat        MessageType = "HEARTBEAT"
	MsgStatus           MessageType = "STATUS"
	MsgHandoff          MessageType = "HANDOFF"
	MsgDone             MessageType = "DONE"
	MsgReadyForReview   MessageType = "READY_FOR_REVIEW"
	MsgReconnect        MessageType = "RECONNECT"
	MsgShutdownApproved MessageType = "SHUTDOWN_APPROVED"
)

// Manager -> Dispatcher message types.
const (
	MsgDirective MessageType = "DIRECTIVE"
)

// Message is the envelope for all UDS messages. The Type field selects which
// payload pointer is populated; unused payloads are nil and omitted from JSON.
type Message struct {
	Type             MessageType              `json:"type"`
	Assign           *AssignPayload           `json:"assign,omitempty"`
	Heartbeat        *HeartbeatPayload        `json:"heartbeat,omitempty"`
	Status           *StatusPayload           `json:"status,omitempty"`
	Handoff          *HandoffPayload          `json:"handoff,omitempty"`
	Done             *DonePayload             `json:"done,omitempty"`
	ReadyForReview   *ReadyForReviewPayload   `json:"ready_for_review,omitempty"`
	Reconnect        *ReconnectPayload        `json:"reconnect,omitempty"`
	PrepareShutdown  *PrepareShutdownPayload  `json:"prepare_shutdown,omitempty"`
	ShutdownApproved *ShutdownApprovedPayload `json:"shutdown_approved,omitempty"`
	Directive        *DirectivePayload        `json:"directive,omitempty"`
	ACK              *ACKPayload              `json:"ack,omitempty"`
	ReviewResult     *ReviewResultPayload     `json:"review_result,omitempty"`
}

// AssignPayload is sent by the dispatcher to assign a bead to a worker.
// MemoryContext contains formatted memories from previous sessions for this bead,
// generated by memory.ForPrompt() and injected by the dispatcher on reassignment.
// CodeSearchContext contains formatted code search results from FTS5Search,
// injected by the dispatcher based on the bead title.
type AssignPayload struct {
	BeadID             string `json:"bead_id"`
	Worktree           string `json:"worktree"`
	Model              string `json:"model,omitempty"`
	MemoryContext      string `json:"memory_context,omitempty"`
	CodeSearchContext  string `json:"code_search_context,omitempty"`
	Feedback           string `json:"feedback,omitempty"`
	Title              string `json:"title,omitempty"`
	Description        string `json:"description,omitempty"`
	AcceptanceCriteria string `json:"acceptance_criteria,omitempty"`
	Attempt            int    `json:"attempt,omitempty"`
}

// Validate checks that the AssignPayload has required fields populated.
// Returns an error if BeadID or Worktree is empty.
func (a *AssignPayload) Validate() error {
	if a.BeadID == "" {
		return fmt.Errorf("bead ID cannot be empty")
	}
	if a.Worktree == "" {
		return fmt.Errorf("worktree cannot be empty")
	}
	return nil
}

// HeartbeatPayload is sent by a worker to report liveness and context usage.
type HeartbeatPayload struct {
	BeadID     string `json:"bead_id"`
	WorkerID   string `json:"worker_id"`
	ContextPct int    `json:"context_pct"`
}

// StatusPayload is sent by a worker to report state transitions.
type StatusPayload struct {
	BeadID   string `json:"bead_id"`
	WorkerID string `json:"worker_id"`
	State    string `json:"state"`
	Result   string `json:"result"`
}

// Summary holds a structured session summary populated by the worker before
// handoff or completion. Persisted as type=summary in the memories table for
// cross-session bead continuity.
type Summary struct {
	Request      string `json:"request"`
	Investigated string `json:"investigated"`
	Learned      string `json:"learned"`
	Completed    string `json:"completed"`
	NextSteps    string `json:"next_steps"`
}

// FormatContent formats the Summary as a pipe-delimited content string
// suitable for storage in the memories table.
func (s *Summary) FormatContent() string {
	return fmt.Sprintf("request: %s | investigated: %s | learned: %s | completed: %s | next_steps: %s",
		s.Request, s.Investigated, s.Learned, s.Completed, s.NextSteps)
}

// HandoffPayload is sent by a worker when it hands off to another worker.
// Includes typed context fields that the worker populates from .oro/ files
// before sending, enabling cross-session memory persistence.
type HandoffPayload struct {
	BeadID         string   `json:"bead_id"`
	WorkerID       string   `json:"worker_id"`
	Learnings      []string `json:"learnings,omitempty"`
	Decisions      []string `json:"decisions,omitempty"`
	FilesModified  []string `json:"files_modified,omitempty"`
	ContextSummary string   `json:"context_summary,omitempty"`
	Summary        *Summary `json:"summary,omitempty"`
}

// DonePayload is sent by a worker when it completes its bead.
type DonePayload struct {
	BeadID            string `json:"bead_id"`
	WorkerID          string `json:"worker_id"`
	QualityGatePassed bool   `json:"quality_gate_passed"`
	QGOutput          string `json:"qg_output,omitempty"`
}

// ReadyForReviewPayload is sent by a worker when its bead is ready for review.
type ReadyForReviewPayload struct {
	BeadID   string `json:"bead_id"`
	WorkerID string `json:"worker_id"`
}

// ReviewResultPayload is sent by the dispatcher to a worker after a review
// completes. Verdict is "approved" or "rejected". On rejection the dispatcher
// typically re-assigns via MsgAssign instead, so this message is primarily
// used for the approval path.
type ReviewResultPayload struct {
	Verdict  string `json:"verdict"`
	Feedback string `json:"feedback,omitempty"`
}

// PrepareShutdownPayload is sent by the dispatcher to request a graceful shutdown.
// The worker should save context (send MsgHandoff with learnings/decisions),
// then reply with MsgShutdownApproved before the timeout expires.
type PrepareShutdownPayload struct {
	Timeout time.Duration `json:"timeout"`
}

// ShutdownApprovedPayload is sent by a worker after it has saved context
// in response to a PrepareShutdown request.
type ShutdownApprovedPayload struct {
	WorkerID string `json:"worker_id"`
}

// ReconnectPayload is sent by a worker reconnecting after a disconnect.
type ReconnectPayload struct {
	WorkerID       string    `json:"worker_id"`
	BeadID         string    `json:"bead_id"`
	State          string    `json:"state"`
	ContextPct     int       `json:"context_pct"`
	BufferedEvents []Message `json:"buffered_events"`
}

// maxBufferedEvents is the maximum number of buffered events allowed in a
// ReconnectPayload. This prevents unbounded memory usage during reconnection.
const maxBufferedEvents = 100

// Validate checks that the ReconnectPayload is within acceptable limits.
// Returns an error if BufferedEvents exceeds maxBufferedEvents.
func (r *ReconnectPayload) Validate() error {
	if len(r.BufferedEvents) > maxBufferedEvents {
		return fmt.Errorf("too many buffered events: %d > %d", len(r.BufferedEvents), maxBufferedEvents)
	}
	return nil
}

// DirectivePayload is sent by the manager to issue directives to the dispatcher.
type DirectivePayload struct {
	Op   string `json:"op"`   // start | stop | pause | focus
	Args string `json:"args"` // optional arguments (e.g., epic ID for focus)
}

// ACKPayload is sent by the dispatcher in response to a directive.
type ACKPayload struct {
	OK     bool   `json:"ok"`
	Detail string `json:"detail,omitempty"`
}

// beadIDPattern validates bead IDs for path safety. Matches IDs like "oro-1nf",
// "oro-1nf.1", "oro-dfe.3". Must start with lowercase letter or digit, followed
// by 0-61 chars of lowercase letters, digits, dots, hyphens, or underscores,
// and must end with lowercase letter or digit.
var beadIDPattern = regexp.MustCompile(`^[a-z0-9][a-z0-9._-]{0,61}[a-z0-9]$`)

// ValidateBeadID validates a bead ID for path safety to prevent directory
// traversal attacks. Returns an error if the ID contains path traversal
// sequences (../, /), special characters, or violates format constraints.
func ValidateBeadID(id string) error {
	if id == "" {
		return fmt.Errorf("bead ID cannot be empty")
	}

	if len(id) < 2 {
		return fmt.Errorf("bead ID must be at least 2 characters")
	}

	if len(id) > 63 {
		return fmt.Errorf("bead ID must not exceed 63 characters")
	}

	if !beadIDPattern.MatchString(id) {
		return fmt.Errorf("bead ID %q is invalid: must start with lowercase letter or digit, followed by lowercase letters, digits, dots, hyphens, or underscores", id)
	}

	return nil
}
